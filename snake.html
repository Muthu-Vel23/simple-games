<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snake Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1115;
      --panel: #1a1f29;
      --accent: #79ffa7;
      --food: #ff5252;
      --grid: #2a3240;
      --text: #e6e6e6;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(1200px 600px at 50% -100px, #1b2030 0%, var(--bg) 50%, var(--bg) 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: grid;
      place-items: center;
      padding: 24px;
    }
    .wrap {
      display: grid;
      gap: 12px;
      align-items: center;
      justify-items: center;
    }
    h1 { margin: 0 0 6px; font-weight: 700; letter-spacing: .5px; }
    .hud {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    .badge {
      background: var(--panel);
      border: 1px solid #2a2f3a;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
    }
    button {
      appearance: none;
      border: 0;
      background: var(--accent);
      color: #072b18;
      font-weight: 700;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform .05s ease;
    }
    button:active { transform: translateY(1px); }
    canvas {
      background: var(--panel);
      border: 2px solid #2b3240;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.04);
      touch-action: none; /* avoids touch scrolling on mobile */
    }
    .tip { font-size: 12px; opacity: .75; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üêç Snake</h1>
    <div class="hud">
      <div class="badge">Score: <span id="score">0</span></div>
      <div class="badge">Speed: <span id="speedLbl">120</span> ms</div>
      <button id="restartBtn">Restart</button>
    </div>
    <canvas id="game" width="400" height="400" aria-label="Snake game board"></canvas>
    <div class="tip">Use Arrow Keys or WASD ‚Ä¢ Avoid walls and yourself ‚Ä¢ Eat the red squares</div>
  </div>

  <script>
    // ====== Config ======
    const CANVAS_SIZE = 400;
    const CELL = 20;                // grid cell size (px)
    const COLS = CANVAS_SIZE / CELL;
    const ROWS = CANVAS_SIZE / CELL;
    const START_SPEED_MS = 120;     // lower = faster
    const SPEED_STEP_MS = 8;        // speed increase size
    const SPEED_EVERY_POINTS = 4;   // increase every N food
    const MIN_SPEED_MS = 60;

    // ====== Canvas ======
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const speedLbl = document.getElementById('speedLbl');
    const restartBtn = document.getElementById('restartBtn');

    // ====== State ======
    let snake, dir, queuedDir, food, score, tickMs, timerId, alive;

    function init() {
      snake = [
        { x: 8, y: 10 },
        { x: 7, y: 10 },
        { x: 6, y: 10 },
      ];
      dir = 'RIGHT';
      queuedDir = 'RIGHT';
      score = 0;
      tickMs = START_SPEED_MS;
      alive = true;
      scoreEl.textContent = score;
      speedLbl.textContent = tickMs;
      placeFood();
      clearInterval(timerId);
      timerId = setInterval(tick, tickMs);
      draw(); // immediate first draw
    }

    function placeFood() {
      while (true) {
        const fx = Math.floor(Math.random() * COLS);
        const fy = Math.floor(Math.random() * ROWS);
        if (!snake.some(s => s.x === fx && s.y === fy)) {
          food = { x: fx, y: fy };
          return;
        }
      }
    }

    // Prevent 180¬∞ reversals and queue changes between ticks
    function setDirection(next) {
      const opposites = { LEFT: 'RIGHT', RIGHT: 'LEFT', UP: 'DOWN', DOWN: 'UP' };
      if (next === opposites[dir]) return;      // ignore direct reverse
      queuedDir = next;
    }

    // ====== Input ======
    window.addEventListener('keydown', (e) => {
      const k = e.key;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(k)) e.preventDefault();
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') setDirection('LEFT');
      else if (k === 'ArrowUp' || k === 'w' || k === 'W') setDirection('UP');
      else if (k === 'ArrowRight' || k === 'd' || k === 'D') setDirection('RIGHT');
      else if (k === 'ArrowDown' || k === 's' || k === 'S') setDirection('DOWN');
      else if (k === ' ') init(); // space to restart quickly
    }, { passive: false });

    restartBtn.addEventListener('click', init);

    // ====== Game Loop ======
    function tick() {
      if (!alive) return;
      dir = queuedDir; // apply queued input once per tick

      const head = snake[0];
      const dx = dir === 'LEFT' ? -1 : dir === 'RIGHT' ? 1 : 0;
      const dy = dir === 'UP' ? -1 : dir === 'DOWN' ? 1 : 0;
      const newHead = { x: head.x + dx, y: head.y + dy };

      // Wall collision
      if (newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS) {
        return gameOver();
      }

      // Self collision (check against current body, tail will move unless we eat)
      if (snake.some((seg, i) => i > 0 && seg.x === newHead.x && seg.y === newHead.y)) {
        return gameOver();
      }

      // Move: add new head
      snake.unshift(newHead);

      // Eat or move tail
      if (newHead.x === food.x && newHead.y === food.y) {
        score++;
        scoreEl.textContent = score;
        placeFood();

        // Speed up every few points
        if (score % SPEED_EVERY_POINTS === 0 && tickMs > MIN_SPEED_MS) {
          tickMs = Math.max(MIN_SPEED_MS, tickMs - SPEED_STEP_MS);
          speedLbl.textContent = tickMs;
          clearInterval(timerId);
          timerId = setInterval(tick, tickMs);
        }
      } else {
        snake.pop(); // normal movement
      }

      draw();
    }

    function gameOver() {
      alive = false;
      clearInterval(timerId);
      // simple overlay
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 28px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 10);
      ctx.font = '16px system-ui';
      ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
      ctx.restore();
    }

    // ====== Rendering ======
    function draw() {
      // background
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel').trim() || '#1a1f29';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // optional grid
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || '#2a3240';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = CELL; x < CANVAS_SIZE; x += CELL) {
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, CANVAS_SIZE);
      }
      for (let y = CELL; y < CANVAS_SIZE; y += CELL) {
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(CANVAS_SIZE, y + 0.5);
      }
      ctx.stroke();

      // food
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--food').trim() || '#ff5252';
      ctx.fillRect(food.x * CELL, food.y * CELL, CELL, CELL);

      // snake
      for (let i = 0; i < snake.length; i++) {
        const seg = snake[i];
        ctx.fillStyle = i === 0
          ? getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#79ffa7'
          : '#8fffc2';
        ctx.fillRect(seg.x * CELL, seg.y * CELL, CELL, CELL);
      }
    }

    // Start immediately
    init();
    // Focus canvas so keys work even after clicks
    window.addEventListener('load', () => canvas.focus());
  </script>
</body>
</html>
